This project is a simple status service which returns minimal information about
the running application. The primary purpose of the application is to serve as
a template or starter project for micro-services built using Spring MVC (rest
services supporting JSON and XML requests and responses) and Spring WS (SOAP
services with XML requests and responses).

SOAP isn't ideal; however, it is required in some legacy environments and once
the infrastructure is in place maintaining support isn't much of a burden
beyond maintaining XML support in the REST services. So I've included it to
demonstrate both:  sharing code between multiple implementation technologies,
and implementing SOAP in Java as elegantly as possible.

Requirements:

* Java JDK 1.8 or newer
* git version control system
* gitflow branching strategy (see below)
* Write access to a maven artifact repository
    * Repository used (configurable)
        * default = Sonatype Nexus 3
    * Maven central mirror (optional)
        * default = http://localhost:8081/repository/maven/
    * Snapshot repository (configurable)
        * default = http://localhost:8081/repository/maven-snapshots/
    * Release repository (configurable)
        * default = http://localhost:8081/repository/maven-releases/

Violating these requirements may require to changes to:  the Jenkins build,
possibly the source code and dependency versions, and may invalidate some or
all of the subsequent instructions in this readme.

To extend this project:

* Clone it into a new git repository
* Update the project parent pom.xml as required for your environment
    * SCM section
        * Replace this repository with your new clone of it
    * repositories section
        * Delete to fetch dependencies directly from maven central
        * Update to change maven central mirror location
    * distributionManagement section
        * Provided Jenkins build requires snapshot and release repositories
        * Also required for "mvn deploy" to work
        * Can be deleted if above functionality won't be used
        * Update to change the snapshot and release repository locations
* The Jenkinsfile will have to be updated if:
    * An artifact repository other than Nexus 3 is used
    * Artifact repository locations are different from those listed above
* Update your local Maven settings (~/.m2/settings.xml) as required
* In the API sub-module:
    * Change package, artifact, and group names as required
    * Add elements and types for new service(s) to XSD file
    * If desired add custom bindings to XJB file to cleanup the Java code
      generated by JAXB (and thus the JSON derived from those Java classes)
* In the service sub-module, for each of your services:
    * Change package, artifact, and group names as required
    * Create a subpackage under common
    * Create an implementation and response builder in the new subpackage
    * Create a REST controller class in the rest subpackage
    * Create a SOAP endpoint class in the soap subpackage

The existing status service implementation is intended to provide an example of
how your services should be implemented. I am assuming that developers forking
this project will remove any pieces (SOAP, REST, XML and/or JSON) which are not
desired for their project.


    User Specific Maven Settings
    ----------------------------

Project settings are stored in the project POM files; however, user specific
settings (like ID's and passwords) have to be stored in a private location. For
Maven this is the ~/.m2/settings.xml file. Here is the minimal settings.xml
file required for all Maven functionality to work as expected with the default
project POM files:

    <settings
        xmlns="http://maven.apache.org/SETTINGS/1.0.0"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="
            http://maven.apache.org/SETTINGS/1.0.0
            https://maven.apache.org/xsd/settings-1.0.0.xsd">
        <servers>
            <server>
                <id>local-snapshots</id>
                <username>????</username>
                <password>????</password>
            </server>
            <server>
                <id>local-releases</id>
                <username>????</username>
                <password>????</password>
            </server>
        </servers>
        <mirrors>
            <mirror>
                <id>local-mirror</id>
                <name>local-mirror</name>
                <url>http://localhost:8081/repository/maven/</url>
                <mirrorOf>*</mirrorOf>
            </mirror>
        </mirrors>
    </settings>

Usernames and passwords will have to be changed to match your environment. If
you've edited the repositories and/or distributionManagement sections of the
POM files it may be necessary to change id values, add new servers, and/or add
new repositories. It may be possible to delete to omit some or all of the
server and mirror elements.


    Git and Git Flow
    ----------------

This project is configured to use Git for source code management with the Git
Flow branching strategy. To summarize Git Flow:

* There are two main branches:  master and develop
* The master branch should be production ready and have a release version
* Developers commit to the develop branch, which should have a snapshot version
* When code is deemed ready for release:
    * Changes are merged to master
    * Versions are incremented in both master and develop
    * The master branch is tagged with the release version
* Other branches will be short lived:
    * Feature branches:
        * Branch from and merge back into develop
        * Name must not be: master, develop, release-*, or hotfix-*
        * Used to isolate potentially disruptive work in progress
    * Release branches:
        * Branch from develop and merge back into both develop and master
        * Naming convention: release-*
        * These are temporary branches used during release process
    * Hotfix branches:
        * Branch from master and merge back into both develop and master
        * Naming convention: hotfix-*
        * Used for urgent fixes to problems discovered in production

The Maven Git Flow plugin automates these branching operations. For additional
information, see the following websites:

    https://git-scm.com/
    http://blogs.atlassian.com/2013/05/maven-git-flow-plugin-for-better-releases/
    http://nvie.com/posts/a-successful-git-branching-model/

The Git Flow strategy and plugin will primarily impact the release process;
however, they should be used whenever creating or merging branches.


    Manual Release Process
    ----------------------

Clone a fresh copy of the Git repository. This isn't strictly necessary but
will make cleanup easier and more reliable if anything goes wrong during the
release process:

    $ git clone git@github.com:denniscourneyea/rest-soap-template.git

Next build the project and perform the release locally:

    $ mvn jgitflow:release-start jgitflow:release-finish

If this completes successfully for all modules, deploy the build artifact(s) to
any and all required test environments and run any required automated or manual
tests in those environments. If any errors occur during the build or subsequent
integration testing, delete the newly cloned working copy of the repository,
fix the problem(s), then try again.

Otherwise, if the build and integration tests succeed, push the release to the
shared git repository:

    $ git push --all
    $ git push --tags
    
Finally, if there is an artifact repository, copy the build artifacts to it.
This could be done in various ways like using a CI/CD server plugin or manually
copying the files. It can also be done, somewhat awkwardly, with Maven:

    $ mvn deploy:deploy-file
        -DpomFile=pom.xml
        -Dfile=pom.xml
        -DrepositoryId=...
        -Durl=...
    $ mvn deploy:deploy-file
        -DpomFile=api/pom.xml
        -Dfile=api/target/*.jar
        -DrepositoryId=...
        -Durl=...
    $ mvn deploy:deploy-file
        -DpomFile=server/pom.xml
        -Dfile=server/target/*.war
        -DrepositoryId=...
        -Durl=...

Maven deploy (mvn deploy) should be avoided because it re-runs the build. Thus
the artifacts uploaded to repositories would not be the same ones tested
earlier.


    Docker Integration
    ------------------

Maven has been configured to optionally build a docker image which serves the
implemented service(s). To generate a Docker image using the last successful
build, execute the following command:

    $ mvn docker:build

If a Docker registry is configured in Maven, the following command will build
the image and publish it to the registry:

    $ mvn docker:push

This functionality is primarily intended for developers to build snapshot
images for local testing, with the added conveniences of integrating the Maven
version and Docker image tag, and automatically using a shared private registry
instead of always defaulting to Docker Hub. It could also be used by a build
server that lacks it's own plugins for Docker integration.


    Continuous Integration (CI) / Continuous Delivery (CD)
    ------------------------------------------------------

In a CI environment a build server will automate both snapshot builds on the
develop branch and release builds (see above). Snapshot builds should be run
frequently - at least daily, and ideally on every push/commit to a shared code
repository. Release builds would be run infrequently, usually triggered
manually after receiving the required approvals and sign offs.

In a CD environment, snapshot builds of the develop branch would be run only on
developer workstations, while every build server build that successfully
completes it's automated test suite(s) should be a release, and either: deployed
to production immediately, or (if management approvals and/or additional manual
testing are required) left to await a manually triggered deployment. Thus,
release builds would be run frequently - again, at least daily, and ideally on
every push/commit to the shared code repository.


    Jenkins Integration
    -------------------

Jenkins is a popular CI/CD server that supports storing and managing it's build
pipeline alongside the application source code. This project includes a
Jenkinsfile that:

* Defines a Jenkins pipeline build
* Supports both Unix and Windows servers (the former is more thoroughly tested)
* Performs a gitflow release as part of the build for use in CD environments
* Publishes and deploys artifacts if, and only if, all tests pass

Since this is a template project with trivial functionality, and every
deployment environment will be different, the integration test and deployment
stages are placeholders which can be customized for your environment.

To use this Jenkinsfile you will have to ensure that the following non-default
plugins are installed on your Jenkins server:

* Docker Plugin
* Git Plugin
* Nexus Artifact Uploader (or equivalent for your chosen artifact repository)
* Pipeline Plugin
* Pipeline Utility Steps

This Jenkins file is designed to be used with the Jenkins "Pipeline" project
type. In Jenkins create a build with the following settings:

* Definition = Pipeline script from SCM
* SCM = Git
* Repository URL and credentials should be set as required for your project
* Branches to build = */develop
* Additional behaviours:
    * Sparse checkout path = /Jenkinsfile
* Script path = Jenkinsfile
* Lightweight checkout = checked

The Jenkins Git Plugin must be used to read the Jenkins file; however, this
executes "git init" followed by "git fetch" instead of a standard "git clone".
Unfortunately this breaks the Maven gitflow plugin; therefore, the Jenkins file
must clear the workspace and run it's own "git clone". A sparse clone is used
above to minimize this inefficiency.

There is one more gotcha. Jenkins security will block the execution of several
methods in the script, the following entries will have to be added to the
"Signatures already approved" list on the "In-process Script Approval" screen
under Manage Jenkins:

* method org.apache.maven.model.Model getVersion
* method java.util.Properties getProperty java.lang.String

Unfortunately there is no way to whitelist them before running a build. Instead
it is necessary to run a build, wait for it to fail, then navigate to the
approval screen and approve the first method. This has to be repeated for each
blocked method until the build eventually succeeds.


    TODO
    ----

* Update dependencies
* Add automated integration tests
* Add more elements to status response, for example:
    * Memory utilization (ideally peak value or a utilization graph)
    * CPU utilization (ideally peak value or a utilization graph)
    * Uptime
* Implement client libraries for REST/JSON, REST/XML, and SOAP
* Move JAXB adapter classes into their own project so they can be reused in other projects
* Create adapter for XSD duration type (combines java.time.Duration & java.time.Period)
